)
cutoff
# Bumphunt candidate regions
message("Step 1: Detecting candidate regions...")
CRI <- callCandidRegion(
gr = gr,
cutoff = cutoff,
maxGap = maxGap,
minNumCR = minNumCR,
bpWindow = bpWindow,
verbose = verbose,
parallel = parallel
) # Outputs list of index vectors. Each list element contains indices in of a CR `gr`.
if (is.null(CRI)) { # End the function if no CR detected
message("...No candidate regions pass the cutoff")
return(NULL)
} else {
pct_incr <- round(sum(lengths(CRI))/length(SE)*100, 2)
message("...Finished calling candidate regions - found ", length(CRI),
" candidate regions in total.
...", pct_incr,
"% QC-passed sites are called to be in candidate regions.")
# Add summary stats (smoothed var and CR index) into output
cr_index <- rep(NA, length(SE))
cr_index[unlist(CRI)] <- rep.int(1:length(CRI), lengths(CRI))
values(gr)$cr_index <- cr_index
# Starting detecting VMRs
message(
"Step 2: Detecting VMRs..."
)
t1 <- proc.time()
vmr.df <- searchVMR( # data frame of VMR information
gr = gr,
CRI = CRI,
# penalty = penalty,
# maxGap = maxGap,
minNumVMR = minNumVMR,
# minNumLong = minNumLong,
# maxNumMerge = maxNumMerge,
tp = tp,
gradient = gradient,
control = control,
verbose = verbose,
parallel = parallel
)
VMRI <- lapply( # list of indices of VMRs
1:nrow(vmr.df),
function(i) vmr.df$start_ind[i]:vmr.df$end_ind[i]
)
t2 <- proc.time()
if (nrow(vmr.df) == 0) {
message("No VMR detected.")
return(NULL)
} else {
message("...Finished detecting VMRs - took ",
round((t2 - t1)[3]/60, 2), " min and ",
nrow(vmr.df), " VMRs found in total.
...", round(sum(vmr.df$end_ind-vmr.df$start_ind+1) / length(SE) * 100, 2),
"% QC-passed sites are called to be in VMRs.")
}
# Formatting function output
vmr_index <- rep(NA, length(SE))
vmr_index[unlist(VMRI)] <- rep.int(1:length(VMRI), lengths(VMRI))
values(gr) <- cbind(values(gr), vmr_index)
vmr.gr <- indexToGranges(gr = gr, Indexes = VMRI)
values(vmr.gr) <- cbind(values(vmr.gr), vmr.df[, -c(3,5)])
cr.gr <- indexToGranges(gr = gr, Indexes = CRI)
return(list(gr = gr, vmr.ranges = vmr.gr, cr.ranges = cr.gr, alpha = alpha, var_cutoff = cutoff, bb_params = pars))
}
CRI
pct_incr <- round(sum(lengths(CRI))/length(SE)*100, 2)
pct_incr <- round(sum(lengths(CRI))/length(SE)*100, 2)
pct_incr <- round(sum(lengths(CRI))/length(SE)*100, 2)
SE <- se
pct_incr <- round(sum(lengths(CRI))/length(SE)*100, 2)
message("...Finished calling candidate regions - found ", length(CRI),
" candidate regions in total.
...", pct_incr,
"% QC-passed sites are called to be in candidate regions.")
# Add summary stats (smoothed var and CR index) into output
cr_index <- rep(NA, length(SE))
cr_index[unlist(CRI)] <- rep.int(1:length(CRI), lengths(CRI))
values(gr)$cr_index <- cr_index
# Starting detecting VMRs
message(
"Step 2: Detecting VMRs..."
)
t1 <- proc.time()
vmr.df <- searchVMR( # data frame of VMR information
gr = gr,
CRI = CRI,
# penalty = penalty,
# maxGap = maxGap,
minNumVMR = minNumVMR,
# minNumLong = minNumLong,
# maxNumMerge = maxNumMerge,
tp = tp,
gradient = gradient,
control = control,
verbose = verbose,
parallel = parallel
)
VMRI <- lapply( # list of indices of VMRs
1:nrow(vmr.df),
function(i) vmr.df$start_ind[i]:vmr.df$end_ind[i]
)
rm(se)
SE <- SE[1:1000, 1:20]
SE <- loadHDF5SummarizedExperiment('../../vmrseq-experiments/data/interim/case_studies/luo2017mice_subset_het/vmrseq/input/chr1/')
SE <- SE[1:1000, 1:20]
# QC: remove sites with across-cell coverage < 3
total <- rowSums(assays(SE)[[1]]>0, na.rm = T)
SE <- SE[total >= 3,]
gr <- vmrseq.smooth(se)
gr <- vmrseq.smooth(SE)
SE
SE <- SE[1:10000, 1:20]
SE <- loadHDF5SummarizedExperiment('../../vmrseq-experiments/data/interim/case_studies/luo2017mice_subset_het/vmrseq/input/chr1/')
SE <- SE[1:10000, 1:20]
# QC: remove sites with across-cell coverage < 3
total <- rowSums(assays(SE)[[1]]>0, na.rm = T)
SE <- SE[total >= 3,]
gr <- vmrseq.smooth(SE)
.libPaths("/home/nshen7/R/rstudio_4_2_0")
library(HDF5Array)
library(SummarizedExperiment)
devtools::load_all('../vmrseq/')
SE <- loadHDF5SummarizedExperiment('../../vmrseq-experiments/data/interim/case_studies/luo2017mice_subset_het/vmrseq/input/chr1/')
SE <- SE[1:10000, 1:20]
# QC: remove sites with across-cell coverage < 3
total <- rowSums(assays(SE)[[1]]>0, na.rm = T)
SE <- SE[total >= 3,]
gr <- vmrseq.smooth(SE)
alpha = 0.05;
maxGap = 2000;
minNumCR = 5; minNumVMR = 5;
maxNumMerge = 0;
minNumLong = 0;
gradient = TRUE;
tp = NULL;
control = vmrseq.optim.control();
verbose = TRUE;
BPPARAM = bpparam()
# Register the parallel backend
BiocParallel::register(BPPARAM)
backend <- paste0("BiocParallel:", class(bpparam())[1])
if (bpparam()$workers == 1) {
if (verbose) {
mes <- "Parallel: Using a single core (backend: %s)."
message(sprintf(mes, backend))
}
parallel <- FALSE
} else {
if (verbose) {
mes <- paste0("Parallel: Parallelizing using %s workers/cores ",
"(backend: %s).")
message(sprintf(mes, bpparam()$workers, backend))
}
parallel <- TRUE
}
# Compute cutoff from beta priors
pars <- getPriorParams(gr$total)
cutoff <- computeVarCutoff(
alpha = alpha,
meth = gr$meth,
total = gr$total,
pars_u =  pars$pars_u,
pars_m = pars$pars_m
)
# Bumphunt candidate regions
message("Step 1: Detecting candidate regions...")
CRI <- callCandidRegion(
gr = gr,
cutoff = cutoff,
maxGap = maxGap,
minNumCR = minNumCR,
bpWindow = bpWindow,
verbose = verbose,
parallel = parallel
) # Outputs list of index vectors. Each list element contains indices in of a CR `gr`.
if (is.null(CRI)) { # End the function if no CR detected
message("...No candidate regions pass the cutoff")
return(NULL)
} else {
pct_incr <- round(sum(lengths(CRI))/length(SE)*100, 2)
message("...Finished calling candidate regions - found ", length(CRI),
" candidate regions in total.
...", pct_incr,
"% QC-passed sites are called to be in candidate regions.")
# Add summary stats (smoothed var and CR index) into output
cr_index <- rep(NA, length(SE))
cr_index[unlist(CRI)] <- rep.int(1:length(CRI), lengths(CRI))
values(gr)$cr_index <- cr_index
# Starting detecting VMRs
message(
"Step 2: Detecting VMRs..."
)
t1 <- proc.time()
vmr.df <- searchVMR( # data frame of VMR information
gr = gr,
CRI = CRI,
# penalty = penalty,
# maxGap = maxGap,
minNumVMR = minNumVMR,
# minNumLong = minNumLong,
# maxNumMerge = maxNumMerge,
tp = tp,
gradient = gradient,
control = control,
verbose = verbose,
parallel = parallel
)
VMRI <- lapply( # list of indices of VMRs
1:nrow(vmr.df),
function(i) vmr.df$start_ind[i]:vmr.df$end_ind[i]
)
t2 <- proc.time()
if (nrow(vmr.df) == 0) {
message("No VMR detected.")
return(NULL)
} else {
message("...Finished detecting VMRs - took ",
round((t2 - t1)[3]/60, 2), " min and ",
nrow(vmr.df), " VMRs found in total.
...", round(sum(vmr.df$end_ind-vmr.df$start_ind+1) / length(SE) * 100, 2),
"% QC-passed sites are called to be in VMRs.")
}
# Formatting function output
vmr_index <- rep(NA, length(SE))
vmr_index[unlist(VMRI)] <- rep.int(1:length(VMRI), lengths(VMRI))
values(gr) <- cbind(values(gr), vmr_index)
vmr.gr <- indexToGranges(gr = gr, Indexes = VMRI)
values(vmr.gr) <- cbind(values(vmr.gr), vmr.df[, -c(3,5)])
cr.gr <- indexToGranges(gr = gr, Indexes = CRI)
return(list(gr = gr, vmr.ranges = vmr.gr, cr.ranges = cr.gr, alpha = alpha, var_cutoff = cutoff, bb_params = pars))
}
pct_incr <- round(sum(lengths(CRI))/length(SE)*100, 2)
message("...Finished calling candidate regions - found ", length(CRI),
" candidate regions in total.
...", pct_incr,
"% QC-passed sites are called to be in candidate regions.")
# Add summary stats (smoothed var and CR index) into output
cr_index <- rep(NA, length(SE))
cr_index[unlist(CRI)] <- rep.int(1:length(CRI), lengths(CRI))
values(gr)$cr_index <- cr_index
# Starting detecting VMRs
message(
"Step 2: Detecting VMRs..."
)
t1 <- proc.time()
vmr.df <- searchVMR( # data frame of VMR information
gr = gr,
CRI = CRI,
# penalty = penalty,
# maxGap = maxGap,
minNumVMR = minNumVMR,
# minNumLong = minNumLong,
# maxNumMerge = maxNumMerge,
tp = tp,
gradient = gradient,
control = control,
verbose = verbose,
parallel = parallel
)
VMRI <- lapply( # list of indices of VMRs
1:nrow(vmr.df),
function(i) vmr.df$start_ind[i]:vmr.df$end_ind[i]
)
t2 <- proc.time()
if (nrow(vmr.df) == 0) {
message("No VMR detected.")
return(NULL)
} else {
message("...Finished detecting VMRs - took ",
round((t2 - t1)[3]/60, 2), " min and ",
nrow(vmr.df), " VMRs found in total.
...", round(sum(vmr.df$end_ind-vmr.df$start_ind+1) / length(SE) * 100, 2),
"% QC-passed sites are called to be in VMRs.")
}
# Formatting function output
vmr_index <- rep(NA, length(SE))
vmr_index
VMRI
vmr.gr <- indexToGranges(gr = gr, Indexes = VMRI)
vmr.gr
values(vmr.gr) <- cbind(values(vmr.gr), vmr.df[, -c(3,5)])
cr.gr <- indexToGranges(gr = gr, Indexes = CRI)
cr.gr
vmr.gr
vmr.df
n_vmr_per_cr <- countOverlaps(vmr.gr, cr.gr)
n_vmr_per_cr
vmr.gr
cr.gr
n_vmr_per_cr <- countOverlaps(cr.gr, vmr.gr)
n_vmr_per_cr
?countOverlaps
sum(n_vmr_per_cr == 1) / sum(n_vmr_per_cr >= 1)
percentage <- sum(n_vmr_per_cr > 1) / length(vmr.gr)
percentage
devtools::check()
.libPaths("/home/nshen7/R/rstudio_4_2_0")
devtools::check()
library(devtools)
use_package('IRanges')
use_package('S4Vectors')
devtools::check()
document()
warnings()
.libPaths("/home/nshen7/R/rstudio_4_2_0")
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gamlss))
suppressPackageStartupMessages(library(HDF5Array))
suppressPackageStartupMessages(library(data.table))
# devtools::load_all()
set.seed(2022)
suppressPackageStartupMessages(library(BiocParallel))
###################################################
######## Train emission beta-binomial model #######
###################################################
sub_liu2021 <- fread("../../vmrseq-experiments/data/interim/estim_emiBetaPrior_ZIBBregression2/emiBetaPrior_subtype_subsample_liu2021_clusterMeth.csv")
sub_luo2017m <- fread("../../vmrseq-experiments/data/interim/estim_emiBetaPrior_ZIBBregression2/emiBetaPrior_subtype_subsample_luo2017mice_clusterMeth.csv")
sub_luo2017h <- fread("../../vmrseq-experiments/data/interim/estim_emiBetaPrior_ZIBBregression2/emiBetaPrior_subtype_subsample_luo2017human_clusterMeth.csv")
sub_liu2021
sub_luo2017m <- fread("../../vmrseq-experiments/data/interim/estim_emiBetaPrior_ZIBBregression2/emiBetaPrior_subtype_subsample_luo2017mice_clusterMeth.csv")
sub_luo2017h <- fread("../../vmrseq-experiments/data/interim/estim_emiBetaPrior_ZIBBregression2/emiBetaPrior_subtype_subsample_luo2017human_clusterMeth.csv")
length(table(sub_liu2021$SubType))
length(table(sub_luo2017m$SubType))
length(table(sub_luo2017h$SubType))
.libPaths("/home/nshen7/R/rstudio_4_2_0")
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gamlss))
suppressPackageStartupMessages(library(HDF5Array))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(BiocParallel))
# devtools::load_all()
set.seed(2022)
# Using default parameters for estimating transition probs:
max_dist_bp = 2000; buffer_bp = 3000
lags = 1:10
degree = 2; span = 0.02
wrapper1 <- function(subtype_dir){
st <- fread(subtype_dir) %>%
filter(cell_cov >= 5) %>% # QC: across-cell coverage >= 5
mutate(cell_MF = cell_meth / cell_cov) %>%
mutate(state = round(cell_MF)) %>%
group_by(chr) %>%
mutate(lag_state = lag(state, 1))
# decide the states for sites with MF = 0.5 based on its previous site
st$state[which(st$cell_MF==0.5)] <- st$lag_state[which(st$cell_MF==0.5)]
smr <- vmrseq:::.computeProb1Unit(
df = st %>% select(chr, pos, state),
max_dist_bp = max_dist_bp,
buffer_bp = buffer_bp,
lags = lags
)
return(smr)
}
# Information of all subtypes used for training
dir <- ("/scratch/st-kdkortha-1/nshen7/vmrseq/vmrseq-experiments/data/processed/summarized_liu2021/")
dir
subtype_dirs <- paste0(dir, list.files(dir))
dir <- ("/scratch/st-kdkortha-1/nshen7/vmrseq/vmrseq-experiments/data/processed/processed_luo2017_mice/")
subtype_dirs <- paste0(dir, grep(pattern = "qced", x = list.files(dir), value = T))  # QCed: across-cell coverage >= 5
subtype_dirs
dir <- ("/scratch/st-kdkortha-1/nshen7/vmrseq/vmrseq-experiments/data/processed/processed_luo2017_human/")
subtype_dirs <- paste0(dir, grep(pattern = "qced", x = list.files(dir), value = T))  # QCed: across-cell coverage >= 5
53+9+9
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(readxl))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(parallel))
setwd("/scratch/st-kdkortha-1/nshen7/vmrseq/vmrseq-experiments/")
source("code/liu2021_data_processing/data_processing_subtypeAcrossSample_helper_functions.R")
source("code/raw_data_process/liu2021_data_processing/data_processing_subtypeAcrossSample_helper_functions.R")
## import metadata
metadata <- fread("data/metadata/metadata_liu2021/Liu2021_cell_full_metadata_processed.csv") %>%
filter(!is.na(GEO_accession) & !is.na(SubType) & !is.na(FilePath))
subtype_smr <- metadata[, .(.N), by = .(CellClass, SubType)] %>%
arrange(desc(N)) %>%
filter(!grepl("Outlier", SubType)) %>%
mutate(Bin = cut(N, breaks = seq(0, ceiling(max(N)/100)*100, 100), labels = F)) %>%
group_by(Bin) %>% mutate(nSubTypeInBin = n())
View(subtype_smr)
rm(list = ls())
usethis::use_version('0.99.0')
library(vmrseq)
devtools::load_all(".")
devtools::load_all()
devtools::load_all()
.libPaths("/home/nshen7/R/rstudio_4_2_0/")
devtools::load_all()
vmrseq:::tp0
vmrseq:::pars
vmrseq:::params_m
vmrseq:::params_u
rm(list = ls())
?GRanges
library(GenomicRanges)
?makeGRangesFromDataFrame
devtools::check()
.libPaths('/home/nshen7/R/rstudio_4_2_0/')
devtools::check()
devtools::document()
warnings()
library(devtools)
document()
lib_path <- "/home/nshen7/R/rstudio_4_2_0"
if (file.exists(lib_path)) .libPaths(lib_path) else message('Lib path not exist!')
document()
?vmrseq.smooth
document()
?vmrseq.smooth
document()
?vmrseq.smooth
source('code/SETPATHS.R')
library(tidyverse)
library(data.table)
library(HDF5Array)
library(SummarizedExperiment)
library(BiocParallel)
n_cores <- 22
register(MulticoreParam(workers = n_cores))
read_dir <- "../../vmrseq-experiments/data/interim/case_studies/luo2017mice_subset_hom/vmrseq/input/"
chr = 'chr`'
chr = 'chr1'
# load input
SE <- loadHDF5SummarizedExperiment(paste0(read_dir, chr))
library(tidyverse)
library(data.table)
library(here)
library(SummarizedExperiment)
library(HDF5Array)
# load input
SE <- loadHDF5SummarizedExperiment(paste0(read_dir, chr))
length(gr)
devtools::document()
.libPaths(lib_pa)
.libPaths(lib_path)
devtools::document()
load_all()
devtools::load_all()
.libPaths(lib_path)
devtools::load_all()
?vmrseq.smooth
granges()
?scMET::scmet
?use_data_raw
gr
read_dir <- "../../vmrseq-experiments/data/interim/case_studies/luo2017mice_subset_het/vmrseq/input/"
# load input
SE <- loadHDF5SummarizedExperiment(paste0(read_dir, chr))
library(dectools)
library(devtools)
document()
?vmrseq:::tp0
vmrseq:::tp0
document
document()
usethis::use_version('0.0.1')
?use_version
usethis::use_version()
usethis::use_version()
?use_version
usethis::use_version()
.libPaths("/home/nshen7/R/rstudio_4_2_0")
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gamlss))
suppressPackageStartupMessages(library(HDF5Array))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(BiocParallel))
# devtools::load_all()
set.seed(2022)
sub_luo2017m <- fread("../../vmrseq-experiments/data/interim/estim_emiBetaPrior_ZIBBregression2/emiBetaPrior_subtype_subsample_luo2017mice_clusterMeth.csv")
head(sub_luo2017m)
unique(sub_luo2017m$SubType)
library(usethis)
?use_vignette
use_vignette('vmrseq', 'Analyzing single-cell bisulfite sequencing data with vmrseq')
library(markdown)
library(markdown)
lib_path <- "/home/nshen7/R/rstudio_4_2_0"
if (file.exists(lib_path)) .libPaths(lib_path) else message('Lib path not exist!')
library(tidyverse)
library(data.table)
library(here)
setwd(here())
here()
library(vmrseq)
library(vmrseq)
library(vmrseq)
.libPaths("/home/nshen7/R/rstudio_4_2_0")
.libPaths()
library(vmrseq)
pacakgeVersion('rlang')
packageVersion('rlang')
?packageVersion
packageVersion('rlang', lib.loc = "/home/nshen7/R/rstudio_4_2_0")
?library
?install.packages
?remove.packages
# library(rlang, lib.loc = "/home/nshen7/R/rstudio_4_2_0")
library(vmrseq, lib.loc = "/home/nshen7/R/rstudio_4_2_0")
.libPaths("/home/nshen7/R/rstudio_4_2_0")
library(vmrseq)
vignette()
vignette('vmrseq')
vignette('.')
system.file(package = 'vmrseq')
dat <- loadRDS("/usr/local/lib/R/site-library/vmrseq/data/Rdata.rds")
dat <- readRDS("/usr/local/lib/R/site-library/vmrseq/data/Rdata.rds")
dat
